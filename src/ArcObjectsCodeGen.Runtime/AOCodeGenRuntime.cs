// ArcObjectsCodeGen.Runtime, all-classes-in-one-file for easy copy-paste.
//

using ESRI.ArcGIS.esriSystem;
using ESRI.ArcGIS.Geodatabase;
using ESRI.ArcGIS.Geometry;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace ArcObjectsCodeGen.Runtime
{
	public static class AoSerializationHelpers
	{
		public static string SerializeViaIPersistStream(object objectToSerialize, Guid coClassID)
		{
			if (objectToSerialize is null)
				throw new ArgumentNullException(nameof(objectToSerialize));
			if (objectToSerialize is not IPersistStream persistStream)
				throw new ArgumentException($"{nameof(objectToSerialize)} doesn't implement {nameof(IPersistStream)}.");

			// Persist object to the byte stream
			IMemoryBlobStream memoryStream = new MemoryBlobStreamClass();
			persistStream.Save(memoryStream, fClearDirty: 1);

			// Export IMemoryBlobStream to byte array
			var memStreamVariant = (IMemoryBlobStreamVariant)memoryStream;
			memStreamVariant.ExportToVariant(out object oSerializedBytes);
			byte[] serializedBytes = (byte[])oSerializedBytes;

			// Pack into coclass_GUID|serialized_sr_as_base64 string ('|' separator is not used in base 64, see https://base64.guru/learn/base64-characters)
			string serializedString = string.Concat(coClassID.ToString(), "|", Convert.ToBase64String(serializedBytes));
			return serializedString;
		}

		public static IAoInterface DeserializeViaIPersistStream<IAoInterface>(string serializedString)
		{
			// Divide serialized string into coclass Guid and serialized spatial reference bytes
			string[] parts = serializedString.Split('|');
			if (parts.Length != 2)
				throw new ArgumentException($"Bad format: {nameof(serializedString)}");

			var coClassID = new Guid(parts[0]);
			var itf = (IAoInterface)Activator.CreateInstance(Type.GetTypeFromCLSID(coClassID));
			var srPresistStream = (IPersistStream)itf;

			byte[] srBytes = Convert.FromBase64String(parts[1]);

			IMemoryBlobStream memoryStream = new MemoryBlobStreamClass();
			var memstreamVariant = (IMemoryBlobStreamVariant)memoryStream;
			memstreamVariant.ImportFromVariant(srBytes);

			srPresistStream.Load(memoryStream);

			return itf;
		}
	}

	/// <summary>
	/// Reader/writer interface for data access objects of type <typeparamref name="TDataObject"/>
	/// (generated by ArcObjectsCodeGen).
	/// Can be used over IRow/IRowBuffer.
	/// </summary>
	public interface IRowReaderWriter<TDataObject>
	{
		/// <summary>
		/// Creates an instance of <typeparamref name="TDataObject"/> class and reads all
		/// available fields from <paramref name="rowBuffer" /> to it.
		/// </summary>
		TDataObject ReadFromRow(IRowBuffer rowBuffer);

		/// <summary>
		/// Writes field values from <paramref name="dataObject"/> to <paramref name="rowBuffer" />.
		/// </summary>
		void WriteToRow(IRowBuffer rowBuffer, TDataObject dataObject);

		// TODO: support for HasOID. Better... redesign this stuff adding support for global ID maps.
		// objectID is whatever IFeatureCursor.InsertFeature returned.
		void SetObjectIDAfterInsert(object objectID, TDataObject dataObject);
	}

	public class FieldGetter<T>
	{
		private readonly int m_FieldIndex;

		public FieldGetter(int fieldIndex)
		{
			m_FieldIndex = fieldIndex;
		}

		public T GetValue(IRowBuffer rowBuffer)
		{
			object rawValue = rowBuffer.get_Value(m_FieldIndex);
			if (DBNull.Value.Equals(rawValue))
				return default;

			if (rawValue is string str && typeof(T) == typeof(Guid))
			{
				rawValue = new Guid(str);
			}
			else if (rawValue is IClone clone)
			{
				rawValue = clone.Clone(); // avoid "recycling" issues
			}

			return (T)rawValue;
		}
	}

	public class FieldSetter<T>
	{
		private readonly int m_FieldIndex;

		public FieldSetter(int fieldIndex)
		{
			m_FieldIndex = fieldIndex;
		}

		public void SetValue(IRowBuffer rowBuffer, T value)
		{
			object rawValue = value;
			if (rawValue is null)
			{
				rawValue = DBNull.Value;
			}
			else if (typeof(T) == typeof(Guid))
			{
				// TODO: specialized GUID getter/setter
				rawValue = (new Guid(value.ToString())).ToString("B").ToUpper();
			}
			else if (rawValue is IClone clone)
			{
				rawValue = clone.Clone(); // avoid "recycling" issues

				// Workaround for esri WTFs: COMException (0x80040907): Geometry cannot have Z values.
				// https://gis.stackexchange.com/a/269233/5834
				if (rawValue is IZAware zAwareRawValue && zAwareRawValue.ZAware && !rowBuffer.Fields.Field[m_FieldIndex].GeometryDef.HasZ)
					zAwareRawValue.ZAware = false;
			}

			rowBuffer.set_Value(m_FieldIndex, rawValue);
		}
	}

	/// <summary>
	/// Manages lifetime of multiple COM objects and IDisposables.
	/// </summary>
	public class Releaser : IDisposable
	{
		private readonly List<object> m_ManagedObjects = new();

		public T ManageLifetime<T>(object obj) where T : class
			=> ManageLifetime((T)obj); // Fail fast with InvalidCastException

		public T ManageLifetime<T>(T obj) where T : class
		{
			if (obj is not null)
				m_ManagedObjects.Add(obj);

			return obj;
		}

		public void Dispose()
		{
			// Release objects in reverse order than they were created
			foreach (object obj in m_ManagedObjects.Reverse<object>())
			{
				if (obj is IDisposable disposable)
					disposable.Dispose();
				else if (Marshal.IsComObject(obj))
					Marshal.ReleaseComObject(obj);
			}

			m_ManagedObjects.Clear();
		}
	}

	public static class ExtensionMethods
	{
		/// <summary>
		/// Invokes:
		/// <code>Marshal.ReleaseComObject(rcw)</code>
		/// </summary>
		/// <param name="rcw">COM interop object (runtime callable wrapper)</param>
		public static void ReleaseComObject(this object rcw) => Marshal.ReleaseComObject(rcw);

		public static void FillWithSamples<TDataObject>(this IFeatureClass featureClass,
			IRowReaderWriter<TDataObject> rowWriter, IEnumerable<TDataObject> samples)
			where TDataObject : new()
		{
			if (featureClass is null)
				throw new ArgumentNullException(nameof(featureClass));
			if (samples is null)
				throw new ArgumentNullException(nameof(samples));

			if (!samples.Any())
				return;

			IFeatureCursor insertCursor = featureClass.Insert(useBuffering: true);
			IFeatureBuffer featureBuffer = featureClass.CreateFeatureBuffer();

			try
			{
				foreach (var sample in samples)
				{
					rowWriter.WriteToRow(featureBuffer, sample);
					object objectID = insertCursor.InsertFeature(featureBuffer);
					rowWriter.SetObjectIDAfterInsert(objectID, sample);
				}

				insertCursor.Flush();
			}
			finally
			{
				featureBuffer?.ReleaseComObject();
				insertCursor?.ReleaseComObject();
			}
		}
	}
}
